'''
Takes 2 inputs: 
1. clustering results from results
2. Structures that were generated by the sampling

Finds and prints representative structure of each cluster
'''

import argparse
from collections import defaultdict

def count(l):
    # l = s.split()
    d = {}
    for x in l:
        if x in d:
            d[x] += 1
        else:
            d[x] = 1
    # print "cluster freq:", sorted(d.values())


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--clusters', dest='cluster_file', required=True)
    parser.add_argument('-s', '--structs', dest='structs_file', required=True)
    args = parser.parse_args()

    structs = []

    for line in open(args.structs_file):
        line = line.strip()
        data = line.split("\t")

        structs.append( (eval(data[1]), float(data[2])) ) 

    #print structs

    clusters = []
    for line in open(args.cluster_file):
        clusters.extend(map(int, line.strip().split() ) )

    count(clusters)
    #print len(clusters)
    #print len(structs)

    numClusters = max(clusters)
    # mapping = defaultdict(list) # {}
    mapping = {}

    outfile = open("struct_to_cluster.out", "w")
    for n,c in enumerate(clusters):
        if c not in mapping:
            mapping[c] = [n]
        else:
            mapping
        # mapping[c].append(n)


        # also need to know which struct is in which cluster
        outfile.write("%s  belongs to   %s \n" % (structs[n], c))

    outfile.close()

    reps = {}
    for k,v in mapping.iteritems():
        reps[k] = max(v, key=lambda x: structs[x][1])

    mapping = reps


    #print mapping



    #do this instead of iteritems for order
    for c in range(1,numClusters+1):
        if c not in mapping:
            sys.stderr.write("ERROR! cluster %s not in mapping\n" % (c,))
            return
        else:
            struct, energy = structs[mapping[c]]
            print "%s\t%s\t%s" % (c, struct, -1*energy)



    



if __name__ == "__main__":
    main()    
